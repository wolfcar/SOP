# 原理分析之如何存储路由

SOP基于spring cloud，因此会涉及到网关路由。但是开发者不用去配置文件定义路由的隐射关系，SOP自动帮你解决了这个问题。

## 获取路由信息

首先明确一点，路由信息由各微服务提供，因此网关需要从注册中心获取各微服务实例，这个通过nacos提供的`watch`来实现。
当有新的微服务加入时，Nacos会触发一个事件推送，详见`NacosWatch.java`类

```java
this.publisher.publishEvent(new HeartbeatEvent(this, this.nacosWatchIndex.getAndIncrement()));
```

因此，只要注册了`HeartbeatEvent`事件就能随时感知到微服务实例的变化。如何注册呢，config类实现`ApplicationListener`接口即可。

```java
public class AbstractConfiguration implements ApplicationContextAware, ApplicationListener<HeartbeatEvent> {
        @EventListener(classes = HeartbeatEvent.class)
        public void listenEvent(ApplicationEvent heartbeatEvent) {
            // 有服务注册进来
        }
}
```

然后，每个微服务提供一个restful接口，接口地址为：`http://ip:port/sop/routes`，用来返回自身路由信息。网关请求这个接口用来获取路由信息。

加载路由伪代码如下：

```java
@Override
public void onAddInstance(InstanceDefinition instance) {
    String serviceName = instance.getServiceId();
    String url = getRouteRequestUrl(instance);
    log.info("拉取路由配置，serviceId: {}, url: {}", serviceName, url);
    ResponseEntity<String> responseEntity = getRestTemplate().getForEntity(url, String.class);
    if (responseEntity.getStatusCode() == HttpStatus.OK) {
        String body = responseEntity.getBody();
        ServiceRouteInfo serviceRouteInfo = JSON.parseObject(body, ServiceRouteInfo.class);
        baseRouteCache.load(serviceRouteInfo, callback -> routesProcessor.saveRoutes(serviceRouteInfo, instance));
    } else {
        log.error("拉取路由配置异常，url: {}, status: {}, body: {}", url, responseEntity.getStatusCodeValue(), responseEntity.getBody());
    }
}
```

参考代码：

- `com.gitee.sop.gatewaycommon.route.RegistryListener`以及实现类
- `com.gitee.sop.gatewaycommon.route.ServiceRouteListener`

路由的存储方式是一个Map，key为路由id，即接口名+版本号。

```java
/**
 * key：nameVersion
 */
private static final Map<String, GatewayTargetRoute> routes = synchronizedMap(new LinkedHashMap<>());
```

因为客户端调用接口都会传递一个接口名和版本号，因此通过这两个字段能够很快查询出路由信息，进行路由转发操作。

